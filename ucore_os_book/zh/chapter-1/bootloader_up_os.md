# Bootloader启动操作系统

## 用一句话描述本章
 站在操作系统的最底层，了解操作系统的起源，与物理硬件：CPU，内存和多种外设实现“零距离”接触，看到它们并管理它们！

## 本章收获的知识
* 与操作系统原理相关
 * I/O设备管理：涉及程序循环检测方式和中断启动方式、I/O地址空间
 * 内存管理：基于分段机制的内存管理
 * 异常处理：涉及中断、故障和陷阱
 * 特权级：内核态和用户态
* 计算机系统和编程
 * 硬件
   * PC从加电到加载操作系统内核的整个过程
   * OS内核在内存中的布局
   * 并口访问、串口访问、CGA字符显示、硬盘数据访问、时钟访问
 * 软件
   * ELF执行文件格式
   * 栈的实现并实现函数调用栈跟踪函数
   * 调试操作系统

## 本章涉及的实验
 读者通过阅读本章的内容并动手实践相关的6个实验项目：
* proj1：能够切换到保护模式并显示字符的bootloader
* proj2/3：可读ELF格式文件的bootloader和显示字符的ucore
* proj3.1：内置监控自身运行状态的ucore
* proj4：可管理中断和处理基于中断的键盘/时钟的ucore
* proj4.1.1：支持通过中断方式的内核态/用户态切换的ucore

## 本章概述

其实这一章的内容与操作系统原理相关的部分较少，与计算机体系结构（特别是x86）的细节相关的部分较多。但这些内容对写一个操作系统关系较大，要知道操作系统是直接与硬件打交道的软件，所以它需要“知道”需要硬件细节，才能更好地控制硬件。另一方面，部分内容涉及到操作系统的重要抽象--中断类异常，能够充分理解中断类异常为以后进一步了解进程切换、上下文切换等概念会很有帮助。

本章的实验内容涉及的是写一个bootloader能够启动一个操作系统--ucore。在完成bootloader的过程中，逐渐增加bootloader和ucore的能力，涉及x86处理器的保护模式切换、解析ELF执行文件格式等，这对于理解操作系统的加载过程以及在操作系统在内存中的位置、内存管理、用户态与内核态的区别等有帮助。而相关project中bootloader和操作系统本身的字符显示的I/O处理、读硬盘数据的I/O处理、键盘/时钟的中断处理等内容，则是操作系统原理中一般在靠后位置提到的设备管理的实际体现。纵观操作系统的发展史，从早期到现在的操作系统主要功能之一就是完成繁琐的I/O处理，给上层应用提供比较简洁的I/O服务，屏蔽硬件处理的复杂性。这也是操作系统的虚拟机功能的体现。另外，本章还介绍了对硬件模拟器的使用，对操作系统的panic处理和远程debug功能的支持，这样有助于读者能够方便地分析操作系统中的错误和调试操作系统。由于本章涉及的硬件知识较多，无疑增大了读者的阅读难度，需要读者在结合阅读本章并实际动手实验来进行深入理解。

